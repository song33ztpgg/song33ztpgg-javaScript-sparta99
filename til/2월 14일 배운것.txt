asa

객체는 복합된 값입니다. 
객체는 여러 가지 값(기본 값이나 다른 객체)를 모아서 이름을 통해 값을 저장하고 가져올 수 있게 합니다. 
객체는 프로퍼티의 순서 없는 집합이며 각 프로퍼티에는 이름과 값이 있습니다. 
프로퍼티 이름은 보통 문자열이므로  기본적인 데이터구조를 '해시', '해시 테이블', '딕셔너리', '연관 배열'같은 이름으로 부르는 데
자바스크립트 객체는 자신만의 프로퍼티를 가지는 것 외에도, '프로토타입'으로 불리는 다른 객체에서 프로퍼티를 상속하기도 합니다. 객체의 메서드는 일반적으로 상속된 프로퍼티이며 이 '프로토타입 상속'이 자바스크립트의 중요한 기능입니다."


 문자열, 숫자, 심벌, true, false, null, undefined가 아닌 값은 전부 객체


함수 Overview
자바스크립트 함수는 매개변수화 됩니다.
 함수 정의에는 매개변수라고 불리는 식별자 리스트가 있는데, 이들은 함수 바디에서 로컬 변수처럼 동작합니다. 함수를 호출할 때는 매개변수에 값을 전달하는데 이를 인자라고 합니다.
 이 값이 함수 호출 표현식의 값이 됩니다. 매개변수 외에도 각 호출에는 호출 컨텍스트가 존재하며 이것이 this 키워드의 값입니다. 
함수는 객체이므로 프로퍼티를 정의할 수 있고 함수의 메서드를 호출하는 것도 가능합니다."
자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며, 이렇게 정의된 함수는 자신이 정의된 스코프의 변수에 접근할 수 있습니다. 이런 의미에서 자바스크립트 함수는 클로저 입니다."

함수는 프로그램을 구성하는 주요 '구성 요소(building block)'

함수 내에서 선언한 변수인 지역 변수
함수 외부에 선언된 변수는 전역 변수,외부변수
역변수를 사용하지 않거나 최소한으로만 사용합니다. 다만 프로젝트 전반에서 사용되는 데이터는 전역 변수에 저장하는 것이 유용한 경우도 있으니 이 점을 알아두시기 바랍니다. 


함수를 선언하고 ()를 안하고 호출하면 전체 코드가 실행되지 않고 문자로 호출된다


변수 = 함수 
변수( ) ==>> 함수( )와 같은 기능을 한다



함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있습니다. = 일반적 함수

함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성합니다.  = 절차지향 방식 느낌
함수는 표현식이나 구문 구성(syntax construct) 내부에 생성됩니다. 아래 예시에선 함수가 할당 연산자 =를 이용해 만든 “할당 표현식” 우측에 생성되었습니다.함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성합니다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있습니다 

이렇게 사용가능 
function showName(one,two,...all){
  // all = ["a","b","c"]
  alert( all[0] ); 
  alert( all[1] ); 
  alert( all[2] );
  alert( all.length ); 
}

...은 '스프레드 문법’입니다.

showName(1,2,"a","b","c");

function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg); 를 사용해 인수를 펼칠 수 있습니다. 
//화살표 문법 사용 불가능
}

Math.max(값) ==>> 가장 큰값 
Array.form(문자열)==>문자열을 낱개로 배열로 뱐환

객체는 중괄호 {…}를 이용해 만들 수 있습니다. 중괄호 안에는 ‘키(key): 값(value)’ 쌍으로 구성된 프로퍼티(property) 를 여러 개 넣을 수 있는데, 키엔 문자형, 값엔 모든 자료형이 허용됩니다. 프로퍼티 키는 ‘프로퍼티 이름’ 이라고도 부릅니다.

let user = new Object(); // '객체 생성자' 문법
let user = {};  // '객체 리터럴' 문법 


왼쪽엔 키(식별자)가, 오른쪽엔 값
전체를 프로퍼티 라고 명칭
키를 값을 연결 시키는 과정(?) 해시,딕셔너리,연관배열

ex) 
doc = {
        'userName':name_receive,
        'userId': id_receive,
        'userPw': pw_receive,
        'postName':None,
        'postContent':None,
        'supportAmount':None
    }


단축 구문
function makeUser(name, age) {
  return {
    name, // name: name 과 같음
    age,  // age: age 와 같음
    // ...
  };
}

in 사용법(프로퍼티 존재여부)
let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.


'정수 프로퍼티’라는 용어는 변형 없이 정수에서 왔다 갔다 할 수 있는 문자열을 의미합니다.

문자열 "49"는 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 변형이 없기 때문에 정수 프로퍼티입니다. 하지만 '+49’와 '1.2’는 정수 프로퍼티가 아닙니다.
alert( String(Math.trunc(Number("49"))) ); // '49'가 출력됩니다. 기존에 입력한 값과 같으므로 정수 프로퍼티입니다.
alert( String(Math.trunc(Number("+49"))) ); // '49'가 출력됩니다. 기존에 입력한 값(+49)과 다르므로 정수 프로퍼티가 아닙니다.
alert( String(Math.trunc(Number("1.2"))) ); // '1'이 출력됩니다. 기존에 입력한 값(1.2)과 다르


객체 프로퍼티에 할당된 함수를 메서드(method)
user에 할당된sayHi를 메서드
ex)
let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("안녕하세요!");
};

user.sayHi(); // 안녕하세요!

ex)다른 예시
// 아래 두 객체는 동일하게 동작합니다.
user = {
  sayHi: function() {
    alert("Hello");
  }
};

// 단축 구문을 사용하니 더 깔끔해 보이네요.
user = {
  sayHi() { // "sayHi: function()"과 동일합니다.
    alert("Hello");
  }
};


큐 :배열을 사용해 만들수 있는 대표적 자료 구죠   선입선출 (pop, push)
스택 : 후입선출(shift, unshift)
push : Z[마지막 자리] 에 요소 추가  
shift  :  Z[0] 

객체화 사용을 하겠다. 

원시 타입 : 실제 데이터 저장,자료형
참조 타입: 객체 주소 저장 . (문자열, 배열, 열거형 상수, 클래스, 인터페이스) 

(딕셔너리)객체 : 여러개의 변수를 하나로 모아놓은것 

==    타입구분 안함 
===  타입구분 함
===================알아낸ㄴ것====================

재곱근 계산은 **

   모르는것=====================


https://ko.javascript.info/object-copy#cloning-and-merging-object-assign

constar let / var => 호이스팅



new 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 초기화를 담당한다.












